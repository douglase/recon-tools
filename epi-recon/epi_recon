#!/usr/bic/bin/python
"""
Program: epi_recon, Read data from fid, take FFT, and write to disk.

One of the first chores of recon_epi is to organize the data into a conventional 
ordering of the data so that various operations may be performed upon the data 
in a manner independent of the order of collection of the phase-encode lines of 
data.

Because Python does not allow indices of arrays (or lists) to start at negative 
values the convention in recon_epi is to number the phase-encode lines as 0 
through 2N-1 where we assume there are 2N phase encode lines (2N = n_pe_true). 
With this convention the phase-encode gradient has zero magnitude at line N-1. 
The following diagram makes this convention clear for the first and second slices 
within a volume (block) of slices:


                        Recon_epi Line Numbering Convention
                       ===================================== 

       recon_epi line                                        k-space k_pe value
      ----------------                                      --------------------

         ^                             ^
         |                    :        |        :
         |                    :        |        :
         |                    :        |        :                                
          \ ____                       | 
          /                            |
         | 4N - 1  <-------------------|------------------->  k_pe = N*del_k
         |                             |
         | 4N - 2  <-------------------|------------------->  k_pe = (N-1)*del_k
         |                    :        |        :
         |                    :        |        :
         |                    :        |        :
         |   N     <-------------------|------------------->  k_pe = del_k
         |                             |
slice 1 -| N - 1   <-------------------|------------------->  k_pe = 0
         |                             |
         | N - 2   <-------------------|------------------->  k_pe = -del_k
         |                    :        |        :
         |                    :        |        :
         |                    :        |        :
         | 2N + 1  <-------------------|------------------->  k_pe = -(N-2)*del_k
         |                             |
         |   2N    <-------------------|------------------->  k_pe = -(N-1)*del_k
          \___                         |
          /                            |
         | 2N - 1  <-------------------|------------------->  k_pe = N*del_k
         |                             |
         | 2N - 2  <-------------------|------------------->  k_pe = (N-1)*del_k
         |                    :        |        :
         |                    :        |        :
         |                    :        |        :
         |   N     <-------------------|------------------->  k_pe = del_k
         |                             |
slice 0 -| N - 1   <-------------------|------------------->  k_pe = 0
         |                             |
         | N - 2   <-------------------|------------------->  k_pe = -del_k
         |                    :        |        :
         |                    :        |        :
         |                    :        |        :
         |   1     <-------------------|------------------->  k_pe = -(N-2)*del_k
         |                             |
         |   0     <-------------------|------------------->  k_pe = -(N-1)*del_k
          \___                         |
                                       |
                                       v


The phase-encode-tables used by recon_epi are created by hand from the scanner-
vendor's phase-encode-table files. While we could use the vendors phase-encode-
tables directly a coding simplification is acheived by using our own file format 
for the phase-encode-tables. Since this need be done only once it is of no great 
cost given benefits. The recon_epi phase-encode-table files are stored in a 
directory named "recon_epi_pettabs".

The different vendors will store their phase-encode tables in different system 
directories. The Varian scanner has the phase-encode tables stored in a directory 
named tablib. 
"""
import sys
from epi_recon_modules import *


#*****************************************************************************
def log_params(params, options):
    """
    Print some of the values of the options and parameters dictionaries to the
    screen. 
    """
    print ""
    print "Phase encode table: ", params['petable']
    print "Pulse sequence: %s" % params['pulse_sequence']
    print "Number of navigator echoes per segment: %d" % params['nav_per_seg']
    print "Number of frequency encodes: %d" % params['n_fe_true']
    print "Number of phase encodes (including navigators if present): %d" % params['n_pe']
    print "Data type: ", params['num_type']
    print "Number of slices: %d" % params['nslice']
    print "Number of frames: %d" % params['nvol']
    print "Number of segments: %d" % params['nseg']
    print "Number of frames to skip: %d" % options.skip
    print "Orientation: %s" % params['orient']
    print "Pixel size (phase-encode direction): %7.2f" % params['xsize'] 
    print "Pixel size (frequency-encode direction): %7.2f" % params['ysize']
    print "Slice thickness: %7.2f" % params['zsize']
    print ""


#*****************************************************************************
def run():
    "Run the epi_recon tool."

    # Get the filename names and options from the command line.
    options = EpiReconOptionParser().getOptions()

    # Get the imaging parameters from the vendor dependent parameter file.
    params = get_params(options)

    # Log some parameter info to the console.
    #log_params(params, options)

    # Load data from the fid file.
    data = get_data(params, options)

    # Now apply the various data manipulation and artifact correction operations
    # to the time-domain (k-space) data which is stored in the arrays
    # data_matrix and nav_data as well as the ancillary data arrays ref_data and
    # ref_anv_data. The operations are applied by looping over the list of
    # operations that the user chooses on the command line. Each operation acts
    # in a independent manner upon the data arrays.
    for operation, args in options.operations:
        if type(operation) == type(Operation) and issubclass(operation, Operation):
            operation(**args).run(params, options, data)
        else: operation(params, options, data)

    # Save data to disk.
    save_image_data(data.data_matrix, params, options)


#*****************************************************************************
if __name__ == "__main__":
    run()
